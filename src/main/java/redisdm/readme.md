# Redis
###为什么使用redis
    主要是从两个角度去考虑:性能和并发。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，
    完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis
###主要问题 
  - 缓存和数据库双写一致性问题  
     - 有强一致性要求的数据，不能放缓存。
     - 最终一致性  
          - 采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列
  - 缓存雪崩问题
     - 即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。  
     - 给缓存的失效时间，加上一个随机值，避免集体失效。
  - 缓存击穿问题  
     - 黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常
     - 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回
  - 缓存的并发竞争问题
         同时有多个子系统去set一个key
    - 无序操作  
         - 准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可;cas锁操作
    - 有序操作  
         - 队列的操作
### 单线程
  - 纯内存操作
  - 单线程操作，避免了频繁的上下文切换
  - 采用了非阻塞I/O多路复用机制
### redis 的过期策略以及内存淘汰机制
   - redis采用的是定期删除+惰性删除策略  
        - 定时删除：用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略。  
        - 定期删除：redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。  
        - 惰性删除：也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。  
        - 淘汰机制：定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。  
### 缓存更新策略
### redis持久化
       redis持久有两种方式:Snapshotting(快照),Append-only file(AOF)
   - Snapshotting(快照 Redis DataBase)  
        - save 900 1   
             900秒内如果超过1个Key被修改，则启动快照保存
        - save 300 10   
            300秒内如果超过10个Key被修改，则启动快照保存
        - save 60 10000     
            60秒内如果超过10000个Key被修改，则启动快照保存
   - 使用AOF持久时，服务会将每个收到的写命令通过write函数追加到文件中（appendonly.aof）
        - 配置
            - appendonly yes  
                开启AOF持久化存储方式 
            - appendfsync always  
                收到写命令后就立即写入磁盘，效率最差，效果最好
            - appendfsync everysec  （默认）
                每秒写入磁盘一次，效率与效果居中
            - appendfsync no  
                完全依赖OS，效率最佳，效果没法保证
        - AOF重写  
             当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集 
        - 日志修复
            如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复 
        - 误操作  
            FLUSHALL后，我们就可以用最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL命令删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态了
   - 启动  
        - RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高 
        - 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效
   - 总结  
        - 如果你对数据的完整性非常敏感，那么RDB方式就不太适合你，因为即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失 。  
        - 官方的建议是两个同时使用。这样可以提供更可靠的持久化方案
        - AOF方式也同样存在缺陷，比如在同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。  
### 架构
       redis是支持主从同步的，而且也支持一主多从以及多级从结构，主从结构，一是为了纯粹的冗余备份，二是为了提升读性能，比如很消耗性能的SORT就可以由从服务器来承担。
    redis的主从同步是异步进行的，这意味着主从同步不会影响主逻辑，也不会降低redis的处理性能。主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。
    主从架构中，从服务器通常被设置为只读模式，这样可以避免从服务器的数据被误修改
   - 主从原理  
        - 从服务器会向主服务器发出SYNC指令，当主服务器接到此命令后，就会调用BGSAVE指令来创建一个子进程专门进行数据持久化工作，也就是将主服务器的数据写入RDB文件中。在数据持久化期间，主服务器将执行的写指令都缓存在内存中。    
        - BGSAVE指令执行完成后，主服务器会将持久化好的RDB文件发送给从服务器，从服务器接到此文件后会将其存储到磁盘上，然后再将其读取到内存中。这个动作完成后，主服务器会将这段时间缓存的写指令再以redis协议的格式发送给从服务器  
        - 即使有多个从服务器同时发来SYNC指令，主服务器也只会执行一次BGSAVE，然后把持久化好的RDB文件发给多个下游
   - Redis+Mysql  
        - Canal 
        - Gearman
        - 程序写redis 
### 事物
     redis指令，MULTI、EXEC、DISCARD、WATCH。这四个指令构成了redis事务处理的基础 
   - 1.MULTI用来组装一个事务；
   - 2.EXEC用来执行一个事务；
   - 3.DISCARD用来取消一个事务；
   - 4.WATCH用来监视一些key，一旦这些key在事务执行之前被改变，则取消事务的执行。                 