package generic

/**
  * 在引入了范型之后，有时候我们需要对接受类型的范围进行一些限制，特别在引入了协变和逆变之后，更需要对于协变的下界和逆变的上界进行界定（在使用范围不对的地方就要进行界定）
  * 参数是逆变的或者不变的，返回值是协变的或者不变的:这句话对下面的方法总结的很到位:
  * 1
  *   入参：是用来被消费的，所以是本身或者是父类
  *   出参：是用来返回的（类型已经是确定的），所以是本身或者子类（子类可以转成父类）
  *
  * 2
  *   逆变(Contravariant)的类型参数T只可能作为函数的参数；
  *   协变(Covariant)的类型参数R只可能作为函数的返回值；
  *   不变的(Nonvariable)类型参数S则没有限制，即可以作为函数的参数，也可以作为返回值
  * 3
  *   当协变类型参数R出现在函数参数时，使用「下界」R1 >: R进行界定，将其转变为不变的(Nonvariable)类型参数R1；
  *   当逆变类型参数T出现在函数返回值时，使用「上界」T1 <: T进行界定，将其转变为不变的(Nonvariable)类型参数T1。
  *
  */
class Consumer[+T](t: T) {
   def f1[U >: T](u : U) = {println(u)}
}
class Producer[-T](t: T) {
  def get[U <: T](u : U): Unit = {println(u)}
}
//因为是协变的，所以可以直接当做参数
class Producer2[-T](t: T) {
    def get(u :T): Unit = {println(u)}
}
object BoundCtronl extends App {

  /**
    * 我们使用一个对象或者一个类必须是什么类型的父类，也可以是接口
    *  表述形式： U >: T
    *  协变往往需要用到下界，类型本身就是下界
    */
  def Lower_Bound(): Unit ={

  }

  /**
    * 我们使用一个对象或者一个类必须是什么类型的父类，也可以是接口
    */
  def Upper_Bound(): Unit ={

  }



    /**
    * 视界 不被社区推荐
    * 表述形式： A <% B
    * 类型A必须“可被视为”类型B，“可被视为”的意思就是存在一个将类A转换为类型B的隐式转换！
    * 下面这段示意代码演示的就是把类型A的实例当作了类型B去使用，因为存在一个从A到B的隐式转换
    */
  def View_Bound(): Unit ={

  }

}
